# zsh configuration for dotfiles-ai
# Modern zsh setup with oh-my-zsh and custom enhancements

# Path to oh-my-zsh installation
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load
ZSH_THEME="agnoster"

# Plugins to load
plugins=(
    git
    zsh-autosuggestions
    zsh-syntax-highlighting
    docker
    kubectl
    aws
    node
    npm
    python
    rust
    golang
)

# Load oh-my-zsh
source $ZSH/oh-my-zsh.sh

# User configuration
export LANG=en_US.UTF-8
export EDITOR='nvim'
export VISUAL='nvim'

# History configuration
HISTSIZE=10000
SAVEHIST=10000
setopt HIST_VERIFY
setopt SHARE_HISTORY
setopt APPEND_HISTORY
setopt INC_APPEND_HISTORY
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_REDUCE_BLANKS
setopt HIST_IGNORE_SPACE

# Directory navigation
unsetopt AUTO_CD
setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
setopt PUSHD_SILENT

# Completion
setopt COMPLETE_ALIASES
setopt ALWAYS_TO_END
setopt AUTO_MENU
setopt AUTO_LIST
setopt AUTO_PARAM_SLASH
setopt COMPLETE_IN_WORD

# Custom aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'

# Git aliases
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git pull'
alias gd='git diff'
alias gb='git branch'
alias gco='git checkout'
alias glog='git log --oneline --graph --decorate'

# Development aliases
alias tmux='tmux a || tmux'

# Directory shortcuts
alias dotfiles='cd ~/.dotfiles-ai'
alias projects='cd ~/projects'

# Aliases from old dotfiles
alias e='$EDITOR'
alias q='exit'
alias c=clear
alias br="bulk-rename"
alias pword='echo $(LC_CTYPE=C tr -dc A-Za-z0-9_\!\@\#\$\%\^\&\*\(\)-+= < /dev/urandom | head -c 32 | xargs)'
alias chromium-no-cors='open -n -a /Applications/Chromium.app/Contents/MacOS/Chromium --args --user-data-dir="/tmp/chrome_dev_test" --disable-web-security'
alias stray_port="lsof -i :"
alias napster='youtube-dl -x --audio-format=mp3'

# Cross-platform clipboard aliases (from old dotfiles)
if ! command -v pbcopy > /dev/null; then
  alias pbcopy="xclip -selection clipboard"
fi

if ! command -v pbpaste > /dev/null; then
  alias pbpaste="xclip -o -selection clipboard"
fi

# System-specific configurations
case "$(uname)" in
    Darwin)
        # macOS specific aliases and functions
        alias brewup='brew update && brew upgrade'
        alias o='open'
        
        # Add Homebrew to PATH if it exists
        if [[ -d "/opt/homebrew/bin" ]]; then
            export PATH="/opt/homebrew/bin:$PATH"
        fi
        ;;
    Linux)
        # Linux specific aliases and functions
        if command -v apt &> /dev/null; then
            alias aptup='sudo apt update && sudo apt upgrade'
            alias aptin='sudo apt install'
            alias apts='apt search'
        fi
        
        if command -v pacman &> /dev/null; then
            alias pacup='sudo pacman -Syu'
            alias pacin='sudo pacman -S'
            alias pacs='pacman -Ss'
        fi
        
        alias o='xdg-open'
        ;;
esac

# Custom functions
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Extract function for various archive types
extract() {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1     ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar e $1     ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xf $1      ;;
            *.tbz2)      tar xjf $1     ;;
            *.tgz)       tar xzf $1     ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *)     echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Find and kill process by name
killp() {
    ps aux | grep $1 | grep -v grep | awk '{print $2}' | xargs kill -9
}

# Weather function (requires curl)
weather() {
    curl -s "wttr.in/$1"
}

# Load Claude CLI aliases and functions if available
# Check multiple possible locations for the Claude configuration
for claude_config in "$HOME/.dotfiles-ai/claude/aliases.zsh" "$HOME/.dotfiles/claude/aliases.zsh" "./claude/aliases.zsh" "$(dirname "${(%):-%N}")/claude/aliases.zsh"; do
    if [[ -f "$claude_config" ]]; then
        source "$claude_config"
        break
    fi
done

# Load Claude personalities if available
for claude_personalities in "$HOME/.dotfiles-ai/claude/personalities.zsh" "$HOME/.dotfiles/claude/personalities.zsh" "./claude/personalities.zsh" "$(dirname "${(%):-%N}")/claude/personalities.zsh"; do
    if [[ -f "$claude_personalities" ]]; then
        source "$claude_personalities"
        break
    fi
done

# Load local customizations if they exist
[[ -f ~/.zshrc.local ]] && source ~/.zshrc.local

# Load environment variables
[[ -f ~/.env ]] && source ~/.env

# Source fzf if available
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# Initialize Starship prompt if available
if command -v starship > /dev/null; then
    eval "$(starship init zsh)"
fi

# Automatic tmux session management
# Auto-connect to existing tmux session or create new one when terminal starts
if command -v tmux &> /dev/null && [ -n "$PS1" ] && [[ ! "$TERM" =~ screen ]] && [[ ! "$TERM" =~ tmux ]] && [ -z "$TMUX" ]; then
    # Check if there are any existing tmux sessions
    if tmux list-sessions &> /dev/null; then
        # Attach to the first available session
        echo "ðŸ”— Connecting to existing tmux session..."
        exec tmux attach-session
    else
        # Create a new tmux session
        echo "ðŸš€ Starting new tmux session..."
        exec tmux new-session
    fi
fi

# Node Version Manager (if installed)
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"

# Rust environment
[[ -f "$HOME/.cargo/env" ]] && source "$HOME/.cargo/env"

# Go environment
export GOPATH="$HOME/go"
export PATH="$PATH:$GOPATH/bin"

# Python environment
export PYTHONPATH="$HOME/.local/lib/python3.9/site-packages:$PYTHONPATH"
export PATH="$HOME/.local/bin:$PATH"

# fzf configuration
[ -f ~/.config/fzf/fzf.zsh ] && source ~/.config/fzf/fzf.zsh

# bat configuration
export BAT_CONFIG_PATH="$HOME/.config/bat/config"

# bat aliases
alias cat="bat"
alias catp="bat -p"           # plain output (no line numbers)
alias catl="bat -l"           # specify language
alias catn="bat --style=numbers"  # only line numbers
alias batdiff="bat --diff"    # show diff
alias batman="bat --language=man"  # syntax highlight man pages

# Use bat as manpager
export MANPAGER="sh -c 'col -bx | bat -l man -p'"

# bat + fzf integration
alias batf="fzf --preview 'bat --color=always --style=numbers --line-range=:500 {}'"


# direnv hook
eval "$(direnv hook zsh)"

# direnv aliases
alias da="direnv allow"
alias db="direnv block"
alias dr="direnv reload"
alias de="direnv edit"
alias ds="direnv status"
alias dp="direnv prune"

# direnv helper functions
direnv-init() {
    # Initialize .envrc in current directory
    if [[ -f .envrc ]]; then
        echo ".envrc already exists"
        return 1
    fi
    
    echo "# direnv configuration" > .envrc
    echo "# https://direnv.net/man/direnv-stdlib.1.html" >> .envrc
    echo "" >> .envrc
    echo "# Load .env file if it exists" >> .envrc
    echo "dotenv_if_exists" >> .envrc
    echo "" >> .envrc
    echo "# Project-specific configuration" >> .envrc
    echo "export PROJECT_NAME=\"$(basename $PWD)\"" >> .envrc
    
    direnv allow
    echo "Created and allowed .envrc"
}

direnv-python() {
    # Create Python layout
    echo "layout python" >> .envrc
    direnv allow
}

direnv-node() {
    # Create Node.js layout
    echo "layout node" >> .envrc
    direnv allow
}

direnv-go() {
    # Create Go layout
    echo "layout go" >> .envrc
    direnv allow
}

direnv-docker() {
    # Setup Docker environment
    cat >> .envrc << 'ENVRC'
# Docker environment
export DOCKER_BUILDKIT=1
export COMPOSE_DOCKER_CLI_BUILD=1
export COMPOSE_PROJECT_NAME="$(basename $PWD)"
ENVRC
    direnv allow
}

direnv-aws() {
    # Setup AWS profile
    local profile="${1:-default}"
    echo "use_aws $profile" >> .envrc
    direnv allow
}

direnv-secrets() {
    # Create .env template for secrets
    if [[ ! -f .env ]]; then
        cat > .env << 'ENV'
# Environment variables
# Copy to .env.local and fill in values

DATABASE_URL=postgresql://user:pass@localhost/dbname
REDIS_URL=redis://localhost:6379
SECRET_KEY=change-me
API_KEY=
ENV
        echo "Created .env template"
    fi
    
    if [[ ! -f .env.local ]]; then
        cp .env .env.local
        echo "Created .env.local - add your secrets here"
    fi
    
    echo "dotenv_if_exists .env.local" >> .envrc
    echo ".env.local" >> .gitignore
    direnv allow
}

direnv-clean() {
    # Clean direnv cache
    rm -rf .direnv
    direnv reload
    echo "Cleaned direnv cache"
}

direnv-debug() {
    # Debug current environment
    direnv status
    echo ""
    echo "Loaded variables:"
    direnv export bash | jq -r 'keys[]'
}


# eza - modern ls replacement
alias ls="eza --icons --group-directories-first"
alias ll="eza --icons --group-directories-first -l"
alias la="eza --icons --group-directories-first -la"
alias lt="eza --icons --group-directories-first --tree"
alias l="eza --icons --group-directories-first -la"

# eza specific aliases
alias ld="eza -lD"                    # directories only
alias lf="eza -lf --color=always | grep -v /"  # files only
alias lh="eza -dl .* --group-directories-first"  # hidden files
alias ll="eza -al --group-directories-first"     # all files, long format
alias ls="eza -a --group-directories-first"      # all files
alias lt="eza --tree --level=2"       # tree view, 2 levels
alias lx="eza -lbhHgmuSa"            # extended details
alias lz="eza -la --sort=size"       # sort by size
alias lt="eza -la --sort=modified"   # sort by modification time

# Git-aware aliases
alias lg="eza -la --git --git-ignore" # show git status
alias ltg="eza --tree --git-ignore"   # tree respecting gitignore


# fd aliases
alias fdd='fd --type d'      # directories only
alias fdf='fd --type f'      # files only
alias fdh='fd --hidden'      # include hidden files
alias fde='fd --extension'   # search by extension
alias fdi='fd --ignore-case' # case insensitive
alias fdx='fd --type x'      # executable files
alias fds='fd --size'        # filter by size


# The next line updates PATH for the Google Cloud SDK.
if [ -f '/home/matt/google-cloud-sdk/path.zsh.inc' ]; then . '/home/matt/google-cloud-sdk/path.zsh.inc'; fi

# The next line enables shell command completion for gcloud.
if [ -f '/home/matt/google-cloud-sdk/completion.zsh.inc' ]; then . '/home/matt/google-cloud-sdk/completion.zsh.inc'; fi

# Google Cloud aliases
alias gc="gcloud"
alias gcl="gcloud config list"
alias gcp="gcloud config set project"
alias gcauth="gcloud auth login"
alias gcconf="gcloud config configurations"

# Compute Engine
alias gce="gcloud compute"
alias gcels="gcloud compute instances list"
alias gcestart="gcloud compute instances start"
alias gcestop="gcloud compute instances stop"
alias gcessh="gcloud compute ssh"
alias gcedisks="gcloud compute disks list"

# Container/Kubernetes
alias gke="gcloud container"
alias gkels="gcloud container clusters list"
alias gkeget="gcloud container clusters get-credentials"

# Cloud Storage
alias gcs="gsutil"
alias gcsls="gsutil ls"
alias gcscp="gsutil cp"
alias gcsmv="gsutil mv"
alias gcsrm="gsutil rm"
alias gcsrsync="gsutil rsync"
alias gcsmb="gsutil mb"  # make bucket
alias gcsrb="gsutil rb"  # remove bucket

# Cloud Functions
alias gcf="gcloud functions"
alias gcfls="gcloud functions list"
alias gcfdeploy="gcloud functions deploy"
alias gcflogs="gcloud functions logs read"

# Cloud Run
alias gcr="gcloud run"
alias gcrls="gcloud run services list"
alias gcrdeploy="gcloud run deploy"

# App Engine
alias gae="gcloud app"
alias gaedeploy="gcloud app deploy"
alias gaelogs="gcloud app logs tail"
alias gaebrowse="gcloud app browse"

# BigQuery
alias bq="bq"
alias bqls="bq ls"
alias bqquery="bq query"

# Pub/Sub
alias gpub="gcloud pubsub"
alias gpubtopics="gcloud pubsub topics list"
alias gpubsubs="gcloud pubsub subscriptions list"

# IAM
alias giam="gcloud iam"
alias giamls="gcloud iam service-accounts list"
alias giamroles="gcloud iam roles list"

# Projects
alias gprojects="gcloud projects list"
alias gproject="gcloud config get-value project"

# Billing
alias gbilling="gcloud billing"
alias gbillingls="gcloud billing accounts list"

# Functions
gcpset() {
    # Set project
    gcloud config set project "$1"
    echo "Project set to: $1"
}

gcpactivate() {
    # Activate service account
    gcloud auth activate-service-account --key-file="$1"
}

gceconnect() {
    # SSH to instance
    gcloud compute ssh "$1" --zone="${2:-us-central1-a}"
}

gcetunnel() {
    # Create SSH tunnel
    local instance="$1"
    local port="${2:-8080}"
    gcloud compute ssh "$instance" -- -L "$port:localhost:$port"
}

gkelogs() {
    # Get GKE cluster logs
    local cluster="$1"
    gcloud container clusters get-credentials "$cluster"
    kubectl logs -f "$2"
}

gcscopy() {
    # Copy between buckets
    gsutil -m cp -r "gs://$1/*" "gs://$2/"
}

gcssize() {
    # Get bucket size
    gsutil du -sh "gs://$1"
}

gcost() {
    # Get cost estimate for current month
    local project="${1:-$(gcloud config get-value project)}"
    gcloud billing budgets list --billing-account="$(gcloud billing accounts list --format='value(name)' --limit=1)"
}

gservices() {
    # List enabled services
    gcloud services list --enabled
}

genable() {
    # Enable API service
    gcloud services enable "$1"
}

gdisable() {
    # Disable API service
    gcloud services disable "$1"
}

# Terraform shortcuts
alias tf="terraform"
alias tfi="terraform init"
alias tfp="terraform plan"
alias tfa="terraform apply"
alias tfd="terraform destroy"
alias tfv="terraform validate"
alias tff="terraform fmt"

# Cloud SQL Proxy
sqlproxy() {
    # Start Cloud SQL proxy
    cloud-sql-proxy "$1" &
}


# htop aliases
alias top="htop"
alias htop-tree="htop -t"     # Tree view
alias htop-user="htop -u $USER"  # Show only current user processes


# Kubernetes aliases
alias k="kubectl"
alias kx="kubectx"
alias kn="kubens"

# kubectl get
alias kg="kubectl get"
alias kgp="kubectl get pods"
alias kgpa="kubectl get pods --all-namespaces"
alias kgd="kubectl get deployments"
alias kgs="kubectl get services"
alias kgi="kubectl get ingress"
alias kgn="kubectl get nodes"
alias kgns="kubectl get namespaces"
alias kgcm="kubectl get configmap"
alias kgsec="kubectl get secret"
alias kgpv="kubectl get pv"
alias kgpvc="kubectl get pvc"

# kubectl describe
alias kd="kubectl describe"
alias kdp="kubectl describe pod"
alias kdd="kubectl describe deployment"
alias kds="kubectl describe service"
alias kdi="kubectl describe ingress"
alias kdn="kubectl describe node"

# kubectl apply/delete
alias ka="kubectl apply -f"
alias kaf="kubectl apply -f"
alias kdel="kubectl delete"
alias kdelf="kubectl delete -f"

# kubectl logs
alias kl="kubectl logs"
alias klf="kubectl logs -f"
alias klt="kubectl logs --tail"

# kubectl exec
alias kex="kubectl exec -it"
alias kexsh="kubectl exec -it -- /bin/sh"
alias kexbash="kubectl exec -it -- /bin/bash"

# kubectl edit
alias ke="kubectl edit"
alias ked="kubectl edit deployment"
alias kes="kubectl edit service"
alias kecm="kubectl edit configmap"

# kubectl scale
alias ksc="kubectl scale"
alias kscd="kubectl scale deployment"

# kubectl port-forward
alias kpf="kubectl port-forward"

# kubectl top
alias ktop="kubectl top"
alias ktopp="kubectl top pods"
alias ktopn="kubectl top nodes"

# Helm aliases
alias h="helm"
alias hi="helm install"
alias hu="helm upgrade"
alias hd="helm delete"
alias hl="helm list"
alias hs="helm search"
alias hr="helm repo"
alias hru="helm repo update"

# k9s
alias k9="k9s"

# Useful functions
kpods() {
    # Get pods with node info
    kubectl get pods -o wide ${1:+--namespace=$1}
}

kexec() {
    # Exec into first pod matching pattern
    local pod=$(kubectl get pods --no-headers -o custom-columns=":metadata.name" | grep -m1 "$1")
    if [[ -n "$pod" ]]; then
        kubectl exec -it "$pod" -- ${2:-/bin/bash}
    else
        echo "No pod found matching: $1"
    fi
}

klogs() {
    # Get logs from first pod matching pattern
    local pod=$(kubectl get pods --no-headers -o custom-columns=":metadata.name" | grep -m1 "$1")
    if [[ -n "$pod" ]]; then
        kubectl logs -f "$pod"
    else
        echo "No pod found matching: $1"
    fi
}

kcontext() {
    # Switch context with fzf
    kubectl config get-contexts -o name | fzf | xargs kubectl config use-context
}

knamespace() {
    # Switch namespace with fzf
    kubectl get namespaces -o name | cut -d/ -f2 | fzf | xargs kubectl config set-context --current --namespace=
}


# kubectl completion
source <(kubectl completion zsh)
compdef k=kubectl

# lazygit aliases
alias lg="lazygit"
alias lzg="lazygit"
alias lgit="lazygit"

# Git + lazygit workflow
alias gs="git status"
alias gst="git status"
alias gss="git status -s"


# Ripgrep configuration
export RIPGREP_CONFIG_PATH="$HOME/.ripgreprc"

# Ripgrep aliases
alias rg='rg --color=auto'
alias rgi='rg -i'  # case insensitive
alias rgf='rg -F'  # fixed string (literal)
alias rgl='rg -l'  # files with matches
alias rgc='rg -c'  # count matches
alias rgn='rg --no-ignore'  # search ignored files too
alias rgh='rg --hidden'  # search hidden files
alias rgw='rg -w'  # whole words only


# Terraform aliases
alias tf="terraform"
alias tfi="terraform init"
alias tfp="terraform plan"
alias tfa="terraform apply"
alias tfaa="terraform apply -auto-approve"
alias tfd="terraform destroy"
alias tfda="terraform destroy -auto-approve"
alias tfv="terraform validate"
alias tff="terraform fmt"
alias tfr="terraform refresh"
alias tfo="terraform output"
alias tfs="terraform state"
alias tfsl="terraform state list"
alias tfss="terraform state show"
alias tfsp="terraform state pull"
alias tfw="terraform workspace"
alias tfwl="terraform workspace list"
alias tfws="terraform workspace select"
alias tfwn="terraform workspace new"

# Terragrunt aliases
alias tg="terragrunt"
alias tgi="terragrunt init"
alias tgp="terragrunt plan"
alias tga="terragrunt apply"
alias tgd="terragrunt destroy"
alias tgv="terragrunt validate"
alias tgf="terragrunt fmt"

# Terraform functions
tfplan() {
    # Plan with output file
    terraform plan -out=tfplan "$@"
}

tfapply() {
    # Apply from plan file
    if [[ -f tfplan ]]; then
        terraform apply tfplan
        rm tfplan
    else
        terraform apply "$@"
    fi
}

tfdiff() {
    # Show plan diff
    terraform plan -detailed-exitcode "$@"
}

tfimport() {
    # Import resource
    terraform import "$@"
}

tfmv() {
    # Move state resource
    terraform state mv "$@"
}

tfrm() {
    # Remove from state
    terraform state rm "$@"
}

tflock() {
    # Lock state
    terraform force-unlock "$@"
}

tfgraph() {
    # Generate dependency graph
    terraform graph | dot -Tpng > terraform-graph.png
    echo "Graph saved to terraform-graph.png"
}

tfcost() {
    # Estimate costs (requires Infracost)
    if command -v infracost &> /dev/null; then
        infracost breakdown --path .
    else
        echo "Infracost not installed"
    fi
}

tfscan() {
    # Security scan
    if command -v tfsec &> /dev/null; then
        tfsec .
    else
        echo "tfsec not installed"
    fi
}

tfdoc() {
    # Generate documentation
    if command -v terraform-docs &> /dev/null; then
        terraform-docs markdown . > README.md
    else
        echo "terraform-docs not installed"
    fi
}

tfclean() {
    # Clean Terraform files
    rm -rf .terraform terraform.tfstate* .terraform.lock.hcl tfplan
    echo "Terraform files cleaned"
}

tfbackup() {
    # Backup state file
    if [[ -f terraform.tfstate ]]; then
        cp terraform.tfstate "terraform.tfstate.backup.$(date +%Y%m%d_%H%M%S)"
        echo "State backed up"
    else
        echo "No state file found"
    fi
}

# Workspace management
tfws-new() {
    terraform workspace new "$1"
    terraform workspace select "$1"
}

tfws-delete() {
    terraform workspace select default
    terraform workspace delete "$1"
}

# Module management
tfmod-init() {
    # Initialize new module
    mkdir -p "$1"
    cd "$1"
    touch main.tf variables.tf outputs.tf README.md
    echo "Module $1 initialized"
}


# Tree aliases
alias t='tree'
alias t1='tree -L 1'
alias t2='tree -L 2'
alias t3='tree -L 3'
alias ta='tree -a'
alias td='tree -d'  # directories only
alias tf='tree -f'  # full path
alias tg='tree --gitignore'  # respect .gitignore
alias ts='tree -h'  # show sizes in human readable
alias tds='tree -d -h'  # directories with sizes


# Go language
export GOROOT="/usr/local/go"
export GOPATH="$HOME/go"
export PATH="$GOROOT/bin:$GOPATH/bin:$PATH"

# Go environment variables
export GO111MODULE="on"
export GOPROXY="https://proxy.golang.org,direct"
export GOSUMDB="sum.golang.org"
export GOPRIVATE=""

# Go aliases
alias gob="go build"
alias gobv="go build -v"
alias goba="go build ./..."
alias gor="go run"
alias gorv="go run -v"
alias gorm="go run main.go"
alias got="go test"
alias gotv="go test -v"
alias gota="go test ./..."
alias gotc="go test -cover"
alias gotcv="go test -cover -v"
alias gotb="go test -bench ."
alias gof="go fmt"
alias gofa="go fmt ./..."
alias gog="go get"
alias gogu="go get -u"
alias goga="go get -u ./..."
alias goi="go install"
alias gom="go mod"
alias gomi="go mod init"
alias gomt="go mod tidy"
alias gomd="go mod download"
alias gomv="go mod vendor"
alias gov="go vet"
alias gova="go vet ./..."
alias gol="golangci-lint run"
alias gola="golangci-lint run ./..."
alias gow="go work"

# Go functions
gocover() {
    go test -coverprofile=coverage.out "$@" && go tool cover -html=coverage.out
}

gonew() {
    if [ -z "$1" ]; then
        echo "Usage: gonew <module-name>"
        return 1
    fi
    mkdir -p "$1" && cd "$1" && go mod init "$1"
}


# sccache for faster Rust compilation
export RUSTC_WRAPPER="sccache"
export SCCACHE_DIR="$HOME/.cache/sccache"
export SCCACHE_CACHE_SIZE="10G"


# 1PASSWORD_INTEGRATION
# 1Password CLI integration
export OP_BIOMETRIC_UNLOCK_ENABLED=true
export SSH_AUTH_SOCK="$HOME/.1password/agent.sock"

# 1Password CLI aliases
alias ops='eval $(op signin)'
alias opget='op item get'
alias oplist='op item list'
alias opssh='op ssh'

# Function to get credentials from 1Password
op-get-password() {
    if [ -z "$1" ]; then
        echo "Usage: op-get-password <item-name>"
        return 1
    fi
    op item get "$1" --fields password
}

# Function to generate and add SSH key to 1Password
op-add-ssh-key() {
    if [ -z "$1" ]; then
        echo "Usage: op-add-ssh-key <key-name>"
        echo "This will generate a new SSH key and store it in 1Password"
        return 1
    fi
    op ssh generate --title "$1"
}

# Function to list SSH keys in 1Password
op-list-ssh-keys() {
    op item list --categories "SSH Key"
}

# AWS CLI completion
autoload bashcompinit && bashcompinit
complete -C '/usr/local/bin/aws_completer' aws

# AWS aliases
alias awsw="aws sts get-caller-identity"  # whoami
alias awsp="aws configure list-profiles"  # list profiles
alias awsr="aws configure get region"     # current region

# Profile switching
awsprofile() {
    export AWS_PROFILE="$1"
    echo "Switched to AWS profile: $1"
    aws sts get-caller-identity
}

# SSO login helper
awssso() {
    aws sso login --profile "${1:-default}"
}

# EC2
alias ec2ls="aws ec2 describe-instances --output table --query 'Reservations[].Instances[].{ID:InstanceId,Type:InstanceType,State:State.Name,Name:Tags[?Key==`Name`]|[0].Value}'"
alias ec2running="aws ec2 describe-instances --filters Name=instance-state-name,Values=running --output table"
alias ec2stop="aws ec2 stop-instances --instance-ids"
alias ec2start="aws ec2 start-instances --instance-ids"
alias ec2terminate="aws ec2 terminate-instances --instance-ids"

# S3
alias s3ls="aws s3 ls"
alias s3mb="aws s3 mb"  # make bucket
alias s3rb="aws s3 rb"  # remove bucket
alias s3cp="aws s3 cp"
alias s3mv="aws s3 mv"
alias s3rm="aws s3 rm"
alias s3sync="aws s3 sync"

# Lambda
alias lambdals="aws lambda list-functions --output table"
alias lambdainvoke="aws lambda invoke"
alias lambdalogs="aws logs tail --follow"

# CloudFormation
alias cfnls="aws cloudformation list-stacks --output table"
alias cfndescribe="aws cloudformation describe-stacks"
alias cfnevents="aws cloudformation describe-stack-events"
alias cfndelete="aws cloudformation delete-stack"

# CloudWatch Logs
alias cwlogs="aws logs tail"
alias cwlogsf="aws logs tail --follow"
alias cwgroups="aws logs describe-log-groups --output table"

# ECS
alias ecsls="aws ecs list-clusters"
alias ecsservices="aws ecs list-services"
alias ecstasks="aws ecs list-tasks"

# RDS
alias rdsls="aws rds describe-db-instances --output table"

# DynamoDB
alias ddbls="aws dynamodb list-tables"
alias ddbdescribe="aws dynamodb describe-table"

# IAM
alias iamusers="aws iam list-users --output table"
alias iamroles="aws iam list-roles --output table"
alias iampolicies="aws iam list-policies --scope Local --output table"

# Cost Explorer
awscost() {
    aws ce get-cost-and-usage \
        --time-period Start=$(date -u -d '30 days ago' '+%Y-%m-%d'),End=$(date -u '+%Y-%m-%d') \
        --granularity MONTHLY \
        --metrics UnblendedCost \
        --group-by Type=DIMENSION,Key=SERVICE \
        --output table
}

# Get AWS account ID
awsaccount() {
    aws sts get-caller-identity --query Account --output text
}

# List all resources in a region
awsresources() {
    aws resourcegroupstaggingapi get-resources --region "${1:-us-east-1}"
}

# AWS Vault shortcuts
alias av="aws-vault"
alias ave="aws-vault exec"
alias avl="aws-vault list"
alias avs="aws-vault login"

# SAM shortcuts
alias sami="sam init"
alias samb="sam build"
alias samd="sam deploy"
alias saml="sam local start-api"
alias samlog="sam logs"

# EKS shortcuts
alias eksls="eksctl get clusters"
alias eksnodes="kubectl get nodes"


# Docker aliases
alias d="docker"
alias dc="docker compose"
alias dps="docker ps"
alias dpsa="docker ps -a"
alias di="docker images"
alias dex="docker exec -it"
alias dl="docker logs"
alias dlf="docker logs -f"
alias dstop="docker stop"
alias dstart="docker start"
alias drm="docker rm"
alias drmi="docker rmi"
alias dprune="docker system prune -a"
alias dvol="docker volume ls"
alias dnet="docker network ls"

# Docker Compose aliases
alias dcu="docker compose up"
alias dcud="docker compose up -d"
alias dcd="docker compose down"
alias dcl="docker compose logs"
alias dclf="docker compose logs -f"
alias dcps="docker compose ps"
alias dcr="docker compose restart"
alias dcb="docker compose build"
alias dce="docker compose exec"

# Docker functions
dsh() {
    # Shell into container
    docker exec -it "$1" /bin/bash 2>/dev/null || docker exec -it "$1" /bin/sh
}

dclean() {
    # Clean up everything
    docker stop $(docker ps -aq) 2>/dev/null || true
    docker rm $(docker ps -aq) 2>/dev/null || true
    docker rmi $(docker images -q) 2>/dev/null || true
    docker volume prune -f
    docker network prune -f
}

dbuild() {
    # Build with cache options
    docker build --no-cache -t "$1" .
}

# Colima aliases (macOS)
if command -v colima &> /dev/null; then
    alias cols="colima start"
    alias colst="colima stop"
    alias colstat="colima status"
    alias colr="colima restart"
fi

# Container tools
alias lzd="lazydocker"


# File watcher aliases and functions

# Basic entr usage
alias watch="entr"
alias watchr="entr -r"  # Restart mode
alias watchc="entr -c"  # Clear screen
alias watchp="entr -p"  # Postpone first execution

# Common watch patterns
watch-run() {
    # Watch files and run command
    # Usage: watch-run "*.js" "npm test"
    local pattern="$1"
    shift
    find . -name "$pattern" | entr -c "$@"
}

watch-test() {
    # Watch and run tests
    local pattern="${1:-*.test.*}"
    shift
    find . -name "$pattern" | entr -c "${@:-npm test}"
}

watch-build() {
    # Watch and rebuild
    find . -name "*.go" -o -name "*.js" -o -name "*.ts" -o -name "*.rs" | entr -c make build
}

watch-python() {
    # Watch Python files and run
    find . -name "*.py" | entr -rc python "${1:-main.py}"
}

watch-node() {
    # Watch JS/TS files and restart node
    find . -name "*.js" -o -name "*.ts" | entr -rc node "${1:-index.js}"
}

watch-go() {
    # Watch Go files and run
    find . -name "*.go" | entr -rc go run "${1:-.}"
}

watch-rust() {
    # Watch Rust files and run
    find . -name "*.rs" -o -name "Cargo.toml" | entr -rc cargo run
}

watch-make() {
    # Watch and run make
    find . -type f -not -path "*/\.*" | entr -c make "${1:-all}"
}

watch-docker() {
    # Watch Dockerfile and rebuild
    echo Dockerfile | entr -c docker build -t "${1:-app}" .
}

watch-compose() {
    # Watch docker-compose and restart
    find . -name "docker-compose*.yml" -o -name "Dockerfile" | entr -rc docker-compose up
}

watch-reload() {
    # Watch and reload browser (requires browser-sync)
    if command -v browser-sync &> /dev/null; then
        browser-sync start --server --files "$1"
    else
        echo "browser-sync not installed"
    fi
}

watch-sass() {
    # Watch SASS/SCSS files
    find . -name "*.scss" -o -name "*.sass" | entr -c sass "${1:-styles.scss}" "${2:-styles.css}"
}

watch-typescript() {
    # Watch TypeScript files
    find . -name "*.ts" -o -name "*.tsx" | entr -c tsc
}

watch-eslint() {
    # Watch and lint JavaScript
    find . -name "*.js" -o -name "*.jsx" | entr -c eslint .
}

watch-prettier() {
    # Watch and format
    find . -name "*.js" -o -name "*.ts" -o -name "*.json" | entr -c prettier --write .
}

watch-pytest() {
    # Watch and run pytest
    find . -name "*.py" | entr -c pytest "${@:--v}"
}

watch-rspec() {
    # Watch and run RSpec
    find . -name "*.rb" | entr -c rspec "${@}"
}

watch-cargo() {
    # Watch and run cargo commands
    find . -name "*.rs" -o -name "Cargo.toml" | entr -c cargo "${@:-test}"
}

watch-git() {
    # Watch files and show git status
    find . -type f -not -path "./.git/*" | entr -c git status
}

watch-sync() {
    # Watch and sync to remote
    find . -type f -not -path "./.git/*" | entr -c rsync -av . "${1:-user@host:/path}"
}

watch-notify() {
    # Watch and send notification
    # Requires terminal-notifier on macOS or notify-send on Linux
    local pattern="$1"
    local message="${2:-Files changed}"
    
    if [[ "$OSTYPE" == "darwin"* ]] && command -v terminal-notifier &> /dev/null; then
        find . -name "$pattern" | entr terminal-notifier -message "$message"
    elif command -v notify-send &> /dev/null; then
        find . -name "$pattern" | entr notify-send "File Watcher" "$message"
    else
        find . -name "$pattern" | entr echo "$message"
    fi
}

# Advanced watch with multiple commands
watch-chain() {
    # Run multiple commands on file change
    # Usage: watch-chain "*.js" "eslint ." "npm test" "npm build"
    local pattern="$1"
    shift
    local commands="$@"
    find . -name "$pattern" | entr -c sh -c "$commands"
}

# Watch with debounce (using sleep)
watch-debounce() {
    # Watch with debounce delay
    local delay="${1:-1}"
    local pattern="$2"
    shift 2
    find . -name "$pattern" | entr -c sh -c "sleep $delay && $@"
}

# Interactive file watcher menu
watch-menu() {
    echo "Select watch mode:"
    echo "1) Watch and run tests"
    echo "2) Watch and build"
    echo "3) Watch and lint"
    echo "4) Watch and restart server"
    echo "5) Custom command"
    
    read -p "Choice: " choice
    
    case $choice in
        1) watch-test ;;
        2) watch-build ;;
        3) watch-eslint ;;
        4) watch-node ;;
        5) 
            read -p "Pattern: " pattern
            read -p "Command: " cmd
            find . -name "$pattern" | entr -c $cmd
            ;;
        *) echo "Invalid choice" ;;
    esac
}

# fswatch aliases (if available)
if command -v fswatch &> /dev/null; then
    fswatch-run() {
        # Watch directory with fswatch
        fswatch -o "${1:-.}" | xargs -n1 -I{} "${@:2}"
    }
    
    fswatch-recursive() {
        # Recursive watch
        fswatch -r "${1:-.}" | xargs -n1 -I{} echo "Changed: {}"
    }
fi

# Watchman aliases (if available)
if command -v watchman &> /dev/null; then
    watchman-init() {
        # Initialize watchman for current directory
        watchman watch .
    }
    
    watchman-trigger() {
        # Create watchman trigger
        local name="$1"
        local pattern="$2"
        shift 2
        watchman -- trigger . "$name" "$pattern" -- "$@"
    }
fi


# HTTP tools aliases

# HTTPie aliases
alias GET="http GET"
alias POST="http POST"
alias PUT="http PUT"
alias PATCH="http PATCH"
alias DELETE="http DELETE"
alias HEAD="http HEAD"

# HTTPie shortcuts
alias http-json="http --json"
alias http-form="http --form"
alias http-download="http --download"
alias http-headers="http --headers"
alias http-verbose="http --verbose"

# curl aliases
alias curl-json="curl -H 'Content-Type: application/json'"
alias curl-post="curl -X POST"
alias curl-put="curl -X PUT"
alias curl-delete="curl -X DELETE"
alias curl-headers="curl -I"
alias curl-verbose="curl -v"
alias curl-silent="curl -s"
alias curl-download="curl -O"
alias curl-follow="curl -L"
alias curl-auth="curl -u"

# Common API testing functions
api-get() {
    http GET "$@"
}

api-post() {
    http POST "$@"
}

api-put() {
    http PUT "$@"
}

api-delete() {
    http DELETE "$@"
}

# JSON pretty print
json-pretty() {
    if command -v jq &> /dev/null; then
        jq .
    elif command -v python3 &> /dev/null; then
        python3 -m json.tool
    else
        cat
    fi
}

# Test API endpoint
api-test() {
    local url="${1:-http://localhost:8080}"
    echo "Testing API at: $url"
    echo "---"
    echo "GET $url"
    http --print=HhBb GET "$url" || curl -i "$url"
}

# Benchmark endpoint
api-bench() {
    local url="${1:-http://localhost:8080}"
    local requests="${2:-100}"
    local concurrency="${3:-10}"
    
    if command -v ab &> /dev/null; then
        ab -n "$requests" -c "$concurrency" "$url"
    elif command -v hey &> /dev/null; then
        hey -n "$requests" -c "$concurrency" "$url"
    else
        echo "Install Apache Bench (ab) or hey for benchmarking"
    fi
}

# Download with resume support
download() {
    local url="$1"
    local output="${2:-$(basename "$url")}"
    curl -L -C - -o "$output" "$url"
}

# Upload file
upload() {
    local file="$1"
    local url="${2:-https://transfer.sh}"
    
    if [[ -f "$file" ]]; then
        curl --upload-file "$file" "$url/$(basename "$file")"
        echo
    else
        echo "File not found: $file"
    fi
}

# Check HTTP status
http-status() {
    local url="$1"
    curl -s -o /dev/null -w "%{http_code}\n" "$url"
}

# Time request
http-time() {
    local url="$1"
    curl -w "@-" -o /dev/null -s "$url" << 'EOF'
    time_namelookup:  %{time_namelookup}s
    time_connect:     %{time_connect}s
    time_appconnect:  %{time_appconnect}s
    time_pretransfer: %{time_pretransfer}s
    time_redirect:    %{time_redirect}s
    time_starttransfer: %{time_starttransfer}s
    ----------
    time_total:       %{time_total}s
EOF
}

# Test REST endpoints
rest-test() {
    local base="${1:-http://localhost:8080}"
    echo "Testing REST endpoints at: $base"
    echo "---"
    echo "GET $base"
    http GET "$base" 2>/dev/null || curl "$base"
    echo "---"
    echo "POST $base"
    http POST "$base" test=data 2>/dev/null || curl -X POST "$base" -d '{"test":"data"}'
}

# GraphQL query
graphql() {
    local url="$1"
    local query="$2"
    
    if [[ -z "$query" ]]; then
        echo "Usage: graphql <url> <query>"
        return 1
    fi
    
    http POST "$url" Content-Type:application/json query="$query"
}

# WebSocket test
ws-test() {
    local url="$1"
    
    if command -v websocat &> /dev/null; then
        websocat "$url"
    elif command -v wscat &> /dev/null; then
        wscat -c "$url"
    else
        echo "Install websocat or wscat for WebSocket testing"
    fi
}

# Bearer token helper
bearer() {
    local token="$1"
    shift
    http "$@" "Authorization:Bearer $token"
}

# Basic auth helper
basic-auth() {
    local user="$1"
    local pass="$2"
    shift 2
    http -a "$user:$pass" "$@"
}


# Monitoring aliases
alias top="htop"  # Use htop instead of top
alias h="htop"
alias bt="btop"
alias g="glances"
alias nc="ncdu"
alias df="duf"
alias ps="procs"

# System monitoring shortcuts
alias cpu="top -o cpu"
alias mem="top -o mem"
alias disk="ncdu /"
alias net="sudo nethogs"
alias io="sudo iotop"
alias bandwidth="bmon"

# Process management
alias psg="ps aux | grep -v grep | grep"
alias kill9="kill -9"
alias killall="pkill"

# System information
sysinfo() {
    echo "=== System Information ==="
    uname -a
    echo
    echo "=== CPU ==="
    lscpu 2>/dev/null || sysctl -n machdep.cpu.brand_string
    echo
    echo "=== Memory ==="
    free -h 2>/dev/null || vm_stat
    echo
    echo "=== Disk ==="
    df -h
    echo
    echo "=== Network ==="
    ip a 2>/dev/null || ifconfig
}

# Monitor specific process
monitor() {
    if [[ -z "$1" ]]; then
        echo "Usage: monitor <process_name>"
        return 1
    fi
    watch -n 1 "ps aux | grep -v grep | grep $1"
}

# Show top memory consumers
topmem() {
    ps aux | sort -rk 4 | head -n "${1:-10}"
}

# Show top CPU consumers
topcpu() {
    ps aux | sort -rk 3 | head -n "${1:-10}"
}

# Show disk usage by directory
diskusage() {
    du -sh "${1:-.}"/* | sort -rh | head -n "${2:-20}"
}

# Show open ports
ports() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sudo lsof -iTCP -sTCP:LISTEN -P
    else
        sudo netstat -tulpn
    fi
}

# Show system load
load() {
    uptime
    echo
    if command -v nproc &> /dev/null; then
        echo "CPU cores: $(nproc)"
    else
        echo "CPU cores: $(sysctl -n hw.ncpu)"
    fi
}

# Temperature monitoring (if available)
temp() {
    if command -v sensors &> /dev/null; then
        sensors
    elif [[ "$OSTYPE" == "darwin"* ]] && command -v osx-cpu-temp &> /dev/null; then
        osx-cpu-temp
    else
        echo "Temperature monitoring not available"
    fi
}

# Network connections
connections() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        netstat -an | grep ESTABLISHED
    else
        ss -tunap | grep ESTAB
    fi
}

# Watch disk I/O
watchio() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sudo fs_usage -w
    else
        sudo iotop
    fi
}

# System health check
health() {
    echo "=== System Health Check ==="
    echo
    echo "Load Average:"
    uptime
    echo
    echo "Memory Usage:"
    free -h 2>/dev/null || vm_stat | head -5
    echo
    echo "Disk Usage:"
    df -h | grep -E "^/dev/"
    echo
    echo "Top Processes:"
    ps aux | sort -rk 3 | head -5
}


# Network tool aliases
alias n="nmap"
alias ns="nmap -sn"  # Ping scan
alias np="nmap -p"   # Port scan
alias nv="nmap -sV"  # Version detection
alias na="nmap -A"   # Aggressive scan

# Port scanning
scan-ports() {
    # Quick port scan
    local host="${1:-localhost}"
    nmap -F "$host"
}

scan-all-ports() {
    # Scan all ports
    local host="${1:-localhost}"
    nmap -p- "$host"
}

scan-tcp() {
    # TCP scan
    local host="${1:-localhost}"
    nmap -sT "$host"
}

scan-udp() {
    # UDP scan (requires root)
    local host="${1:-localhost}"
    sudo nmap -sU "$host"
}

scan-network() {
    # Scan local network
    local network="${1:-192.168.1.0/24}"
    nmap -sn "$network"
}

# Netcat shortcuts
alias nc-listen="nc -l"
alias nc-scan="nc -zv"

# Network testing
test-port() {
    # Test if port is open
    local host="$1"
    local port="$2"
    nc -zv "$host" "$port"
}

http-server() {
    # Quick HTTP server
    local port="${1:-8000}"
    python3 -m http.server "$port"
}

tcp-server() {
    # Simple TCP server
    local port="${1:-9999}"
    nc -l "$port"
}

tcp-client() {
    # Connect to TCP server
    local host="$1"
    local port="$2"
    nc "$host" "$port"
}

# MTR (My TraceRoute)
alias mtr="mtr --report-wide --show-ips"
alias mtrr="mtr --report --report-cycles 30"

trace() {
    # Enhanced traceroute
    local host="$1"
    if command -v mtr &> /dev/null; then
        mtr "$host"
    else
        traceroute "$host"
    fi
}

# DNS tools
alias d="dig"
alias dx="dig +short"
alias dns="dig +trace"

dns-lookup() {
    # DNS lookup with multiple tools
    local domain="$1"
    echo "=== nslookup ==="
    nslookup "$domain"
    echo
    echo "=== dig ==="
    dig "$domain"
    echo
    echo "=== host ==="
    host "$domain"
}

reverse-dns() {
    # Reverse DNS lookup
    dig -x "$1"
}

# Network information
myip() {
    # Get public IP
    curl -s ifconfig.me
    echo
}

localip() {
    # Get local IP
    if [[ "$OSTYPE" == "darwin"* ]]; then
        ifconfig | grep "inet " | grep -v 127.0.0.1 | awk "{print \$2}"
    else
        ip addr show | grep "inet " | grep -v 127.0.0.1 | awk "{print \$2}"
    fi
}

ports() {
    # Show listening ports
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sudo lsof -iTCP -sTCP:LISTEN -P
    else
        sudo netstat -tulpn
    fi
}

connections() {
    # Show network connections
    if [[ "$OSTYPE" == "darwin"* ]]; then
        netstat -an | grep ESTABLISHED
    else
        ss -tunap | grep ESTAB
    fi
}

# Bandwidth testing
speed() {
    # Run speedtest
    if command -v speedtest &> /dev/null; then
        speedtest
    elif command -v speedtest-cli &> /dev/null; then
        speedtest-cli
    else
        echo "speedtest not installed"
    fi
}

bandwidth() {
    # Test bandwidth between hosts
    local mode="${1:-server}"
    if [[ "$mode" == "server" ]]; then
        iperf3 -s
    else
        iperf3 -c "$1"
    fi
}

# Packet capture
capture() {
    # Capture packets
    local interface="${1:-any}"
    local output="${2:-capture.pcap}"
    sudo tcpdump -i "$interface" -w "$output"
}

capture-http() {
    # Capture HTTP traffic
    sudo tcpdump -i any -s 0 -A "tcp port 80"
}

capture-dns() {
    # Capture DNS queries
    sudo tcpdump -i any -s 0 port 53
}

# WHOIS shortcuts
alias w="whois"

whois-ip() {
    whois "$1" | grep -E "(OrgName|NetRange|CIDR|Country)"
}

# Socat examples
proxy-tcp() {
    # TCP proxy
    local lport="$1"
    local rhost="$2"
    local rport="$3"
    socat TCP-LISTEN:"$lport",fork TCP:"$rhost":"$rport"
}

# RustScan (if installed)
if command -v rustscan &> /dev/null; then
    alias rs="rustscan"
    alias rscan="rustscan -a"
    
    fast-scan() {
        rustscan -a "$1" -- -A -sC -sV
    }
fi

# Network debugging
net-debug() {
    local host="${1:-google.com}"
    echo "=== Ping ==="
    ping -c 4 "$host"
    echo
    echo "=== Traceroute ==="
    traceroute "$host"
    echo
    echo "=== DNS ==="
    dig "$host"
    echo
    echo "=== Port 80/443 ==="
    nc -zv "$host" 80
    nc -zv "$host" 443
}


# PostgreSQL aliases
alias psql="psql -U postgres"
alias pg="psql"
alias pgd="psql -d"
alias pgl="psql -l"  # List databases
alias pgdu="psql -c \"SELECT datname, pg_size_pretty(pg_database_size(datname)) FROM pg_database ORDER BY pg_database_size(datname) DESC;\""  # Database sizes
alias pgt="psql -c \"SELECT schemaname,tablename FROM pg_tables WHERE schemaname NOT IN ('pg_catalog', 'information_schema');\""  # List tables

# PostgreSQL functions
pgconnect() {
    # Connect with common format
    psql "postgresql://${1:-localhost}:${2:-5432}/${3:-postgres}?user=${4:-postgres}"
}

pgdump() {
    # Dump database
    pg_dump -U postgres -h localhost -d "$1" -f "${1}_$(date +%Y%m%d_%H%M%S).sql"
}

pgrestore() {
    # Restore database
    psql -U postgres -h localhost -d "$1" -f "$2"
}

pgsize() {
    # Get table sizes
    psql -U postgres -d "$1" -c "SELECT schemaname, tablename, pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size FROM pg_tables WHERE schemaname NOT IN ('pg_catalog', 'information_schema') ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC LIMIT 20;"
}

pgkill() {
    # Kill query by PID
    psql -U postgres -c "SELECT pg_terminate_backend($1);"
}

